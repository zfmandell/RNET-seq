#!/usr/bin/env python
# Metaplot_Generator 0.0.1
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# See https://documentation.dnanexus.com/developer for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os
import dxpy
import numpy as np
import pandas as pd
from pandas.api.types import CategoricalDtype
from plotnine import *

def GFF_build(fyle):
    return_list = []
    with open(fyle,'r') as inp:
        for line in inp:
            if len(line.strip().split('\t')) > 1:
                if line.strip().split('\t')[2] == 'gene':
                    start = int(line.strip().split('\t')[3])
                    end = int(line.strip().split('\t')[4])
                    strand = line.strip().split('\t')[6]
                    return_list.append([start,end,strand])
    
    return return_list

def read_coverage(cov_fyle):
    #create list of coverage values, position dependent
    return_list = []
    with open(cov_fyle,"r") as inp:
        for line in inp:
            return_list.append(float(line.strip().split('\t')[2]))
    return return_list

def read_ends(fyle):
    return_list = []
    with open(fyle,'r') as inp:
        firstline = inp.readline()
        for line in inp:
            coord = line.strip().split(',')[0]
            strand = line.strip().split(',')[1]
            return_list.append(coord+'_'+strand)
    
    return return_list

def TPM_scaling(fwd,rev,genes):
    RPK = []
    for value in genes:
        if value[2] == '+':
            RPK.append(sum(fwd[value[0]:value[1]+1])/(abs(value[0]-value[1])+1/1000))
        else:
            RPK.append(sum(rev[value[0]:value[1]+1])/(abs(value[0]-value[1])+1/1000))

    return sum(RPK)/1000000

def TPM_crunch(ends,upstream,downstream,window,step,fwd,rev,scaling):
    final_list = []
    for item in ends:
        coord = int(item.split('_')[0])
        strand = item.split('_')[1]
        if coord-upstream > 1 and coord+downstream < len(fwd): 
            TPM = []
            if strand == '+':
                bins = [fwd[i:i+window] for i in list(range(coord-upstream,coord+downstream+1,step))]
                for subitem in bins:
                    TPM.append(round((sum(subitem)/(window/1000))/scaling,1))
            else:
                bins = [rev[i:i+window] for i in list(range(coord-downstream,coord+upstream+1,step))][::-1]
                for subitem in bins:
                    TPM.append(round((sum(subitem)/(window/1000))/scaling,1))
            final_list.append(TPM)

    median_list = []
    for item in range(0,len(final_list[0])):
        median_list.append(round(np.log10(np.median([x[item] for x in final_list])),1))

    return median_list

@dxpy.entry_point('main')
def main(coords, GFF3, fwd_coverage_A, rev_coverage_A, fwd_coverage_B, rev_coverage_B, condition_A, condition_B, upstream, downstream, window, step, output):

    # The following line(s) initialize your data object inputs on the platform
    # into dxpy.DXDataObject instances that you can start using immediately.

    coords = dxpy.DXFile(coords)
    GFF3 = dxpy.DXFile(GFF3)
    fwd_coverage_A = dxpy.DXFile(fwd_coverage_A)
    rev_coverage_A = dxpy.DXFile(rev_coverage_A)
    fwd_coverage_B = dxpy.DXFile(fwd_coverage_B)
    rev_coverage_B = dxpy.DXFile(rev_coverage_B)

    # The following line(s) download your file inputs to the local file system
    # using variable names for the filenames.

    dxpy.download_dxfile(coords.get_id(), "coords")

    dxpy.download_dxfile(GFF3.get_id(), "GFF3")

    dxpy.download_dxfile(fwd_coverage_A.get_id(), "fwd_coverage_A")

    dxpy.download_dxfile(rev_coverage_A.get_id(), "rev_coverage_A")

    dxpy.download_dxfile(fwd_coverage_B.get_id(), "fwd_coverage_B")

    dxpy.download_dxfile(rev_coverage_B.get_id(), "rev_coverage_B")

    # Fill in your application code here.

    ends = read_ends("coords")
    GFF3 = GFF_build("GFF3")
    fwd_A = read_coverage("fwd_coverage_A")
    rev_A = read_coverage("rev_coverage_A")
    fwd_B = read_coverage("fwd_coverage_B")
    rev_B = read_coverage("rev_coverage_B")
    scaling_A = TPM_scaling(fwd_A,rev_A,GFF3)
    scaling_B = TPM_scaling(fwd_B,rev_B,GFF3)

    median_list_A = TPM_crunch(ends,upstream,downstream,window,step,fwd_A,rev_A,scaling_A)
    median_list_B = TPM_crunch(ends,upstream,downstream,window,step,fwd_B,rev_B,scaling_B)

    all_loc = []
    current = upstream*-1
    all_loc.append(current)
    while current < downstream:
        current += step
        all_loc.append(current)

    all_cond = [condition_A]*len(all_loc)+[condition_B]*len(all_loc)
    all_loc = all_loc*2
    all_median = median_list_A+median_list_B

    final_for_df = {'distance':all_loc,'condition':all_cond,'TPM':all_median}

    df = pd.DataFrame(final_for_df)

    # The following line(s) use the Python bindings to upload your file outputs
    # after you have created them on the local file system.  It assumes that you
    # have used the output field name for the filename for each output, but you
    # can change that behavior to suit your needs.

    plot = (ggplot(df)
        + aes(x='distance',y='TPM',group='condition',color='condition')
        + scale_color_grey() 
        + theme_classic()
        + geom_line(linetype="dashed", size=1.2)
        + geom_point(color="red", size=3)        
        + labs(x='distance', y='log10 TPM')
        )
    plot.save(output, height=6, width=8)

    # The following line fills in some basic dummy output and assumes
    # that you have created variables to represent your output with
    # the same name as your output fields.

    metaplot = dxpy.upload_local_file(output)
    output = {}
    output["metaplot"] = dxpy.dxlink(metaplot)

    return output

dxpy.run()
