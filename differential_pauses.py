#!/usr/bin/env python
# Differential_Pauses 0.0.1
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# See https://documentation.dnanexus.com/developer for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os
import dxpy
import numpy as np
import collections

def genome_yield(fasta_name):
    seq = ''
    with open(fasta_name) as inp:
        for line in inp:
            if line[0] != '>':
                seq = seq+str(line.strip())
    return seq

def reverse_complement(seq):
    complement = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A','a': 't', 'c': 'g', 'g': 'c', 't': 'a'}
    bases = list(seq)
    bases = reversed([complement.get(base,base) for base in bases])
    bases = ''.join(bases)
    return bases

def pause_place_TU_plus(coord,TU):
    sites = np.array(list(TU.keys()))
    TSS = sites[sites < coord].max()
    return TSS,TU[TSS]

def pause_place_TU_minus(coord,TU):
    sites = np.array(list(TU.keys()))
    TSS = sites[sites > coord].min()
    return TU[TSS],TSS

def pause_place_GFF(gene,strand,GFF3):
    if strand == '+':
        return GFF3[gene][0],GFF3[gene][1]
    else:
        return GFF3[gene][1],GFF3[gene][0]

def plus_place(pos,lyst):
    for item in sorted(lyst):
        if pos < item:
            return item

def minus_place(pos,lyst):
    for item in sorted(lyst,reverse=True):
        if pos > item:
            return item

def GFF_build(fyle):
    return_dict,CDS_fwd,CDS_rev = {},{},{}
    with open(fyle,'r') as inp:
        for line in inp:
            if len(line.strip().split('\t')) > 1:
                if line.strip().split('\t')[2] == 'gene':
                    gene = line.strip().split('\t')[8].split('=')[3].split(';')[0]
                    start = int(line.strip().split('\t')[3])
                    end = int(line.strip().split('\t')[4])
                    strand = line.strip().split('\t')[6]
                    return_dict[gene] = [start,end]
                    if strand == '+':
                        CDS_fwd[start] = end
                    else:
                        CDS_rev[end] = start
    
    return return_dict,CDS_fwd,CDS_rev

def TU_build(TSS,TTS):
    TU_plus,TU_minus = {},{}
    TSS_plus,TTS_plus,TSS_minus,TTS_minus = [],[],[],[]
    with open(TTS,'r') as inp:
        firstline = inp.readline()
        for line in inp:
            if line.strip().split(',')[1] == '+':
                TTS_plus.append(int(line.strip().split(',')[0]))
            else:
                TTS_minus.append(int(line.strip().split(',')[0]))
    with open(TSS,'r') as inp:
        firstline = inp.readline()
        for line in inp:
            if line.strip().split(',')[1] == '+':
                TSS_plus.append(int(line.strip().split(',')[0]))
            else:
                TSS_minus.append(int(line.strip().split(',')[0]))

    for item in sorted(TSS_plus):
        TU_plus[item] = plus_place(item,TTS_plus)
    for item in sorted(TSS_minus,reverse=True):
        TU_minus[item] = minus_place(item,TTS_minus)

    empty_plus =  [x[0] for x in [(k, v) for k, v in TU_plus.items() if not v]]
    empty_minus =  [x[0] for x in [(k, v) for k, v in TU_minus.items() if not v]]

    for item in empty_plus:
        TU_plus[item] = sorted(TTS_plus)[0]
    for item in empty_minus:
        TU_minus[item] = sorted(TTS_minus,reverse=True)[0]

    return collections.OrderedDict(sorted(TU_plus.items())),collections.OrderedDict(sorted(TU_minus.items(),reverse=True))

def TPM_scaling(TU_fwd,TU_rev,fwd,rev):
    RPK = []
    for key,value in TU_fwd.items():
        RPK.append(sum(fwd[key:value+1])/(abs(key-value)/1000))
    for key,value in TU_rev.items():
        RPK.append(sum(fwd[value:key+1])/(abs(key-value)/1000))

    return sum(RPK)/1000000

def TPM_calc(coord,strand,TU_fwd,TU_rev,fwd,rev,scaling):
        if strand == '+':
            small,big = pause_place_TU_plus(coord,TU_fwd)
            RPK = sum(fwd[small:big+1])/(abs(small-big)/1000)
            return RPK/scaling
        else:
            small,big = pause_place_TU_minus(coord,TU_rev)
            RPK = sum(rev[small:big+1])/(abs(small-big)/1000)
            return RPK/scaling

def TPM_calc_CDS(start,end,cov,scaling):
    RPK = sum(cov[start:end+1])/(abs(start-end)/1000)
    return RPK/scaling

def median(lst):
    n = len(lst)
    s = sorted(lst)
    return (sum(s[n//2-1:n//2+1])/2.0, s[n//2])[n % 2] if n else None

def read_coverage(cov_fyle):
    #create list of coverage values, position dependent
    return_list = []
    with open(cov_fyle,"r") as inp:
        for line in inp:
            return_list.append(int(line.strip().split('\t')[2]))
    return return_list

def read_wig(wig_fyle):
    #create list of coverage values, position dependent
    return_dict = {}
    with open(wig_fyle,"r") as inp:
        for line in inp:
            return_dict[int(line.strip().split('\t')[0])] = [int(line.strip().split('\t')[1]),float(line.strip().split('\t')[3])]
    return return_dict

def read_pause(fyle):
    return_dict = {}
    gene_dict ={}
    with open(fyle,'r') as inp:
        firstline = inp.readline()
        for line in inp:
            if int(line.strip().split('\t')[8]) > 0:
                peak = int(line.strip().split('\t')[1])
                strand = '+'
                gene = line.strip().split('\t')[0]
                offset = line.strip().split('\t')[2]
                sense = line.strip().split('\t')[6]
            else:
                peak = int(line.strip().split('\t')[1])
                strand = '-'
                gene = line.strip().split('\t')[0]
                offset = line.strip().split('\t')[2]
                sense = line.strip().split('\t')[6]

            return_dict[peak] = [strand]
            gene_dict[peak] = [gene,sense,offset]

    return return_dict,gene_dict

def pause_rank(pauses_WT,pauses_Mutant,wig_WT,wig_Mutant):
    ranked = {}
    for key,value in pauses_WT.items():
        strand = value[0]
        count_WT = wig_WT[key][0]
        count_Mutant = wig_Mutant[key][0]
        Median_WT = wig_WT[key][1]
        Median_Mutant = wig_Mutant[key][1]
        if Median_WT == 0:
            if strand == '+':
                Median_WT = 1
            else:
                Median_WT = -1
        if abs(Median_Mutant) > 1 and abs(count_Mutant) !=0:
            if np.sign(count_WT) == np.sign(count_Mutant) and np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_WT = round(abs(count_WT)/abs(Median_WT),2)
                Score_Mutant = round(abs(count_Mutant)/abs(Median_Mutant),2)
                ranked[str(key)+'_'+str(strand)] = [abs(count_WT),abs(count_Mutant),abs(Median_WT),abs(Median_Mutant),Score_WT,Score_Mutant]
        elif abs(Median_Mutant) > 1 and abs(count_Mutant) == 0:
            if np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_WT = round(abs(count_WT)/abs(Median_WT),2)
                ranked[str(key)+'_'+str(strand)] = [abs(count_WT),0,abs(Median_WT),abs(Median_Mutant),abs(Score_WT),0]

    for key,value in pauses_Mutant.items():
        strand = value[0]
        count_WT = abs(wig_WT[key][0])
        count_Mutant = abs(wig_Mutant[key][0])
        Median_WT = abs(wig_WT[key][1])
        Median_Mutant = abs(wig_Mutant[key][1])
        if Median_Mutant == 0:
            if strand == '+':
                Median_Mutant = 1
            else:
                Median_Mutant = -1
        if abs(Median_WT) > 1 and abs(count_WT) !=0:
            if np.sign(count_WT) == np.sign(count_Mutant) and np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_WT = round(abs(count_WT)/abs(Median_WT),2)
                Score_Mutant = round(abs(count_Mutant)/abs(Median_Mutant),2)
                ranked[str(key)+'_'+str(strand)] = [abs(count_WT),abs(count_Mutant),abs(Median_WT),abs(Median_Mutant),Score_WT,Score_Mutant]
        elif abs(Median_WT) > 1 and abs(count_WT) == 0:
            if np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_Mutant = round(abs(count_Mutant)/abs(Median_Mutant),2)
                ranked[str(key)+'_'+str(strand)] = [0,abs(count_Mutant),abs(Median_WT),abs(Median_Mutant),0,abs(Score_Mutant)]

    return ranked


def printer(name,ranked,genes_WT,genes_Mutant,WT_fwd,WT_rev,Mutant_fwd,Mutant_rev,GFF3,TU_fwd,TU_rev,CDS_fwd,CDS_rev,scaling_wt,scaling_mut,sequence,upstream,downstream,CDS_wt,CDS_mut):
    with open(name,'w') as outp:
        outp.write('coord,strand,gene,offset,sense,WT CDS TPM,Mutant CDS TPM,Log2FC-CDS TPM,WT TU TPM,Mutant TU TPM,Log2FC-TU TPM,TSS,TTS,start,stop,dist_TSS,dist_TTS,dist_start,dist_stop,WT Count,Mutant Count,WT Median,Mutant Median,WT Score,Mutant Score,log2FC-Pause,FC-short,FC-16,FC-17,FC-18,FC-long,sequence,threshold\n')
        for key,value in dyct.items():
            coord = int(key.split('_')[0])
            strand = str(key.split('_')[1])

            if int(coord) in genes_WT.keys():
                gene = str(genes_WT[int(coord)][0])
                sense = str(genes_WT[int(coord)][1])
                offset = str(genes_WT[int(coord)][2])
            else:
                gene = str(genes_Mutant[int(coord)][0])
                sense = str(genes_Mutant[int(coord)][1])
                offset = str(genes_WT[int(coord)][2])

            start,stop = pause_place_GFF(gene,strand,GFF3)

            if strand == '+':
                TSS,TTS = pause_place_TU_plus(coord,TU_fwd)
                dTSS = coord-TSS
                dTTS = coord-TTS
                dstart = coord-start
                dstop = coord-stop
            else:
                TTS,TSS = pause_place_TU_minus(coord,TU_rev)
                dTSS = TSS-coord
                dTTS = TTS-coord
                dstart = start-coord
                dstop = stop-coord

            WT_counts = value[0]
            Mutant_counts = value[1]
            WT_Median = value[2]
            Mutant_Median = value[3]

            WT_Score = value[4]
            if 0 < WT_Score < 1:
                WT_Score = round(WT_Score,0)

            Mutant_Score = value[5]
            if 0 < Mutant_Score < 1:
                Mutant_Score = round(Mutant_Score,0)

            WT_TPM = TPM_calc(coord,strand,TU_fwd,TU_rev,WT_fwd,WT_rev,TU_scaling_wt)
            Mutant_TPM = TPM_calc(coord,strand,TU_fwd,TU_rev,Mutant_fwd,Mutant_rev,TU_scaling_mut)
            
            if strand = '+':
                WT_CDS = TPM_calc_CDS(start,stop,WT_fwd,CDS_wt)
                Mutant_CDS = TPM_calc_CDS(start,stop,Mutant_fwd,CDS_wt)
            else:
                WT_CDS = TPM_calc_CDS(start,stop,WT_rev,CDS_wt)
                Mutant_CDS = TPM_calc_CDS(start,stop,Mutant_rev,CDS_wt)
        
            if WT_TPM > 0 and Mutant_TPM > 0:
                Log2FC_TU = round(np.log2(Mutant_TPM/WT_TPM),2)
            else:
                Log2FC_TU = 'NA'

            if WT_CDS > 0 and Mutant_CDS > 0:
                Log2FC_CDS = round(np.log2(Mutant_CDS/WT_CDS),2)
            else:
                Log2FC_CDS = 'NA'
             if WT_Score > 0 and Mutant_Score > 0:
                Log2FC = round(np.log2(Mutant_Score/WT_Score),2)
            else:
                Log2FC = 'NA'
            
            """

            if WT_TPM > 0:
                WT_Score_TPM = WT_Score/WT_TPM
            else:
                WT_Score_TPM = 0
            if Mutant_TPM > 0:
                Mutant_Score_TPM = Mutant_Score/Mutant_TPM
            else:
                Mutant_Score_TPM = 0
            if WT_Score_TPM > 0 and Mutant_Score_TPM > 0:
                Log2FC_TPM = round(np.log2(Mutant_Score_TPM/WT_Score_TPM),2)
            else:
                Log2FC_TPM = 'NA'

            if abs(WT_Score-Mutant_Score) != 0:
                Log2Diff = round(np.log2(abs(WT_Score-Mutant_Score)),2)
            else:
                Log2Diff = 0
            if abs(WT_Score_TPM-Mutant_Score_TPM) != 0:
                Log2Diff_TPM = round(np.log2(abs(WT_Score_TPM-Mutant_Score_TPM)),2)
            else:
                Log2Diff_TPM = 0
            """

            if Log2FC != 'NA':
                if abs(Log2FC_TPM) >= 3:
                    differential = 'TRUE'
                else:
                    differential = 'FALSE'

            if strand == '+':
                seq = genome[coord-1].upper()
                seq = genome[coord-1-upstream:coord-1].lower()+seq
                seq = seq+genome[coord:coord+downstream].lower()
            else:
                seq = genome[coord-1].upper()
                seq = genome[coord-1-downstream:coord-1].lower()+seq
                seq = seq+genome[coord:coord+upstream].lower()
                seq = reverse_complement(seq)

            if WT_TPM != 0 and Mutant_TPM != 0:
                outp.write(str(coord)+','+strand+','+gene+','+sense+','+str(TSS)+','+str(TTS)+','+str(start)+','+str(stop)+','+str(dTSS)+','+str(dTTS)+','+str(dstart)+','+str(dstop)+\
                ','+str(WT_counts)+','+str(Mutant_counts)+','+str(WT_Median)+','+str(Mutant_Median)+','+str(WT_Score)+','+str(Mutant_Score)+','+str(WT_TPM)+','+str(Mutant_TPM)+\
                ','+str(Log2FC)+','+str(seq)+','+differential+'\n')

@dxpy.entry_point('main')
def main(TSS, TTS, GFF3, genome, upstream, downstream, WT_Pauses, Mutant_Pauses, WT_Raw, Mutant_Raw, WT_coverage_fwd, WT_coverage_rev, Mutant_coverage_fwd, Mutant_coverage_rev):

    # The following line(s) initialize your data object inputs on the platform
    # into dxpy.DXDataObject instances that you can start using immediately.

    TSS = dxpy.DXFile(TSS)
    TTS = dxpy.DXFile(TTS)
    GFF3 = dxpy.DXFile(GFF3)
    genome = dxpy.DXFile(genome)
    WT_Pauses = dxpy.DXFile(WT_Pauses)
    Mutant_Pauses = dxpy.DXFile(Mutant_Pauses)
    WT_Raw = dxpy.DXFile(WT_Raw)
    Mutant_Raw = dxpy.DXFile(Mutant_Raw)
    WT_coverage_fwd = dxpy.DXFile(WT_coverage_fwd)
    WT_coverage_rev = dxpy.DXFile(WT_coverage_rev)
    Mutant_coverage_fwd = dxpy.DXFile(Mutant_coverage_fwd)
    Mutant_coverage_rev = dxpy.DXFile(Mutant_coverage_rev)

    # The following line(s) download your file inputs to the local file system
    # using variable names for the filenames.

    dxpy.download_dxfile(TSS.get_id(), "TSS")

    dxpy.download_dxfile(TTS.get_id(), "TTS")

    dxpy.download_dxfile(GFF3.get_id(), "GFF3")

    dxpy.download_dxfile(genome.get_id(), "genome")

    dxpy.download_dxfile(WT_Pauses.get_id(), "WT_Pauses")

    dxpy.download_dxfile(Mutant_Pauses.get_id(), "Mutant_Pauses")

    dxpy.download_dxfile(WT_Raw.get_id(), "WT_Raw")

    dxpy.download_dxfile(Mutant_Raw.get_id(), "Mutant_Raw")

    dxpy.download_dxfile(WT_coverage_fwd.get_id(), "WT_coverage_fwd")

    dxpy.download_dxfile(WT_coverage_rev.get_id(), "WT_coverage_rev")

    dxpy.download_dxfile(Mutant_coverage_fwd.get_id(), "Mutant_coverage_fwd")

    dxpy.download_dxfile(Mutant_coverage_rev.get_id(), "Mutant_coverage_rev")

    # Fill in your application code here.

    #build genome dict
    sequence = genome_yield("genome")

    #build pause dict
    pauses_WT,genes_WT = read_pause("WT_Pauses")
    pauses_Mutant,genes_Mutant = read_pause("Mutant_Pauses")

    #load up gff file and build TU and CDS dicts
    GFF3,CDS_fwd,CDS_rev = GFF_build('GFF3')
    TU_fwd,TU_rev = TU_build('TSS','TTS')

    #clean up TU dicts
    for key,value in dict(TU_fwd).items():
        if value < key:
            del TU_fwd[key]
    for key,value in dict(TU_rev).items():
        if value > key:
            del TU_rev[key]

    #clean up pause dicts
    for key,value in pauses_WT.items():
        if value == '+':
            if key < min(TU_fwd.keys()):
                del pauses_WT[key]
        else:
            if key > max(TU_rev.keys()):
                del pauses_WT[key]

    for key,value in pauses_Mutant.items():
        if value == '+':
            if key < min(TU_fwd.keys()):
                del pauses_Mutant[key]
        else:
            if key > max(TU_rev.keys()):
                del pauses_Mutant[key]

    #load up wig files
    WT_wig,Mutant_wig = read_wig("WT_Raw"),read_wig("Mutant_Raw")

    #rank all pauses
    ranked = pause_rank(pauses_WT,pauses_Mutant,WT_wig,Mutant_wig)

    #clear large wigs
    WT_wig,Mutant_wig = {},{}

    #build coverage lists
    WT_fwd = read_coverage('WT_coverage_fwd')
    WT_rev = read_coverage('WT_coverage_rev')
    Mutant_fwd = read_coverage('Mutant_coverage_fwd')
    Mutant_rev = read_coverage('Mutant_coverage_rev')

    #calculate all TPMs of TUs and CDSs
    scaling_wt,scaling_mut = TPM_scaling(TU_fwd,TU_rev,WT_fwd,WT_rev),TPM_scaling(TU_fwd,TU_rev,Mutant_fwd,Mutant_rev)
    CDS_wt,CDS_mut = TPM_scaling(CDS_fwd,CDS_rev,WT_fwd,WT_rev),TPM_scaling(CDS_fwd,CDS_rev,Mutant_fwd,Mutant_rev)
    
    # The following line(s) use the Python bindings to upload your file outputs
    # after you have created them on the local file system.  It assumes that you
    # have used the output field name for the filename for each output, but you
    # can change that behavior to suit your needs.

    printer("Differential_Pauses.csv",ranked,genes_WT,genes_Mutant,WT_fwd,WT_rev,Mutant_fwd,Mutant_rev,GFF3,TU_fwd,TU_rev,CDS_fwd,CDS_rev,scaling_wt,scaling_mut,sequence,upstream,downstream,CDS_wt,CDS_mut)

    Differential_Pauses = dxpy.upload_local_file("Differential_Pauses.csv")

    # The following line fills in some basic dummy output and assumes
    # that you have created variables to represent your output with
    # the same name as your output fields.

    output = {}
    output["Differential_Pauses"] = dxpy.dxlink(Differential_Pauses)

    return output

dxpy.run()
