#!/usr/bin/env python
# differential_pauses_bb 0.0.2
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# See https://documentation.dnanexus.com/developer for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os
import dxpy
import numpy as np
import collections

def genome_yield(fasta_name):
    seq = ''
    with open(fasta_name) as inp:
        for line in inp:
            if line[0] != '>':
                seq = seq+str(line.strip())
    return seq

def reverse_complement(seq):
    complement = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A','a': 't', 'c': 'g', 'g': 'c', 't': 'a'}
    bases = list(seq)
    bases = reversed([complement.get(base,base) for base in bases])
    bases = ''.join(bases)
    return bases

def length_distribution(fyle):
    return_dict = {}
    with open(fyle,'r') as inp:
        for line in inp:
            coord = int(line.strip().split()[0])
            shrt = int(line.strip().split()[5])
            sixteen = int(line.strip().split()[6])
            seventeen = int(line.strip().split()[7])
            eighteen = int(line.strip().split()[8])
            lng = int(line.strip().split()[9])

            total = shrt+sixteen+seventeen+eighteen+lng

            if total != 0:
                return_dict[coord] = [round(shrt/total,2),round(sixteen/total,2),round(seventeen/total,2),round(eighteen/total,2),round(lng/total,2)]
            else:
                return_dict[coord] = 'NA'
    return return_dict

def pause_place_TU_plus(coord,TU):
    sites = np.array(list(TU.keys()))
    TSS = sites[sites < coord].max()
    return TSS,TU[TSS]

def pause_place_TU_minus(coord,TU):
    sites = np.array(list(TU.keys()))
    TSS = sites[sites > coord].min()
    return TU[TSS],TSS

def pause_place_GFF(gene,strand,GFF3):
    if strand == '+':
        return GFF3[gene][0],GFF3[gene][1]
    else:
        return GFF3[gene][1],GFF3[gene][0]

def plus_place(pos,lyst):
    for item in sorted(lyst):
        if pos < item:
            return item

def minus_place(pos,lyst):
    for item in sorted(lyst,reverse=True):
        if pos > item:
            return item

def GFF_build(fyle):
    return_dict,CDS_fwd,CDS_rev = {},{},{}
    with open(fyle,'r') as inp:
        for line in inp:
            if len(line.strip().split('\t')) > 1:
                if line.strip().split('\t')[2] == 'gene':
                    gene = line.strip().split('\t')[8].split(';')[2].split('=')[1]
                    start = int(line.strip().split('\t')[3])
                    end = int(line.strip().split('\t')[4])
                    strand = line.strip().split('\t')[6]
                    return_dict[gene] = [start,end]
                    if strand == '+':
                        CDS_fwd[start] = end
                    else:
                        CDS_rev[end] = start
                        
    return return_dict,CDS_fwd,CDS_rev

def TPM_scaling(TU_fwd,TU_rev,fwd,rev):
    RPK = []
    for key,value in TU_fwd.items():
        RPK.append(sum(fwd[key:value+1])/(abs(key-value)/1000))
    for key,value in TU_rev.items():
        RPK.append(sum(fwd[value:key+1])/(abs(key-value)/1000))

    return sum(RPK)/1000000

def TPM_calc(coord,strand,TU_fwd,TU_rev,fwd,rev,scaling):
        if strand == '+':
            small,big = pause_place_TU_plus(coord,TU_fwd)
            RPK = sum(fwd[small:big+1])/(abs(small-big)/1000)
            return RPK/scaling
        else:
            small,big = pause_place_TU_minus(coord,TU_rev)
            RPK = sum(rev[small:big+1])/(abs(small-big)/1000)
            return RPK/scaling

def TPM_calc_CDS(start,end,cov,scaling):
    RPK = sum(cov[start:end+1])/(abs(start-end)/1000)
    return RPK/scaling

def median(lst):
    n = len(lst)
    s = sorted(lst)
    return (sum(s[n//2-1:n//2+1])/2.0, s[n//2])[n % 2] if n else None

def read_coverage(cov_fyle):
    #create list of coverage values, position dependent
    return_list = []
    with open(cov_fyle,"r") as inp:
        for line in inp:
            return_list.append(int(line.strip().split('\t')[2]))
    return return_list

def read_wig(wig_fyle):
    #create list of coverage values, position dependent
    return_dict = {}
    with open(wig_fyle,"r") as inp:
        for line in inp:
            return_dict[int(line.strip().split('\t')[0])] = [int(line.strip().split('\t')[1]),float(line.strip().split('\t')[3])]
    return return_dict

def read_pause(fyle):
    return_dict = {}
    gene_dict ={}
    with open(fyle,'r') as inp:
        firstline = inp.readline()
        for line in inp:
            if int(line.strip().split('\t')[8]) > 0:
                peak = int(line.strip().split('\t')[1])
                strand = '+'
                gene = line.strip().split('\t')[0]
                offset = line.strip().split('\t')[2]
                AKA = line.strip().split('\t')[12].replace(',',':')
                plus1 = line.strip().split('\t')[15]
                sense = line.strip().split('\t')[6]
            else:
                peak = int(line.strip().split('\t')[1])
                strand = '-'
                gene = line.strip().split('\t')[0]
                offset = line.strip().split('\t')[2]
                AKA = line.strip().split('\t')[12].replace(',',':')
                plus1 = line.strip().split('\t')[15]
                sense = line.strip().split('\t')[6]

            return_dict[peak] = [strand]
            gene_dict[peak] = [gene,sense,offset,AKA,plus1]

    return return_dict,gene_dict

def pause_rank(pauses_WT,pauses_Mutant,wig_WT,wig_Mutant):
    ranked = {}
    for key,value in pauses_WT.items():
        strand = value[0]
        count_WT = wig_WT[key][0]
        count_Mutant = wig_Mutant[key][0]
        Median_WT = wig_WT[key][1]
        Median_Mutant = wig_Mutant[key][1]
        if Median_WT == 0:
            if strand == '+':
                Median_WT = 1
            else:
                Median_WT = -1
        if abs(Median_Mutant) > 1 and abs(count_Mutant) !=0:
            if np.sign(count_WT) == np.sign(count_Mutant) and np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_WT = round(abs(count_WT)/abs(Median_WT),2)
                Score_Mutant = round(abs(count_Mutant)/abs(Median_Mutant),2)
                ranked[str(key)+'_'+str(strand)] = [abs(count_WT),abs(count_Mutant),abs(Median_WT),abs(Median_Mutant),Score_WT,Score_Mutant]
        elif abs(Median_Mutant) > 1 and abs(count_Mutant) == 0:
            if np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_WT = round(abs(count_WT)/abs(Median_WT),2)
                ranked[str(key)+'_'+str(strand)] = [abs(count_WT),0,abs(Median_WT),abs(Median_Mutant),abs(Score_WT),0]

    for key,value in pauses_Mutant.items():
        strand = value[0]
        count_WT = abs(wig_WT[key][0])
        count_Mutant = abs(wig_Mutant[key][0])
        Median_WT = abs(wig_WT[key][1])
        Median_Mutant = abs(wig_Mutant[key][1])
        if Median_Mutant == 0:
            if strand == '+':
                Median_Mutant = 1
            else:
                Median_Mutant = -1
        if abs(Median_WT) > 1 and abs(count_WT) !=0:
            if np.sign(count_WT) == np.sign(count_Mutant) and np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_WT = round(abs(count_WT)/abs(Median_WT),2)
                Score_Mutant = round(abs(count_Mutant)/abs(Median_Mutant),2)
                ranked[str(key)+'_'+str(strand)] = [abs(count_WT),abs(count_Mutant),abs(Median_WT),abs(Median_Mutant),Score_WT,Score_Mutant]
        elif abs(Median_WT) > 1 and abs(count_WT) == 0:
            if np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_Mutant = round(abs(count_Mutant)/abs(Median_Mutant),2)
                ranked[str(key)+'_'+str(strand)] = [0,abs(count_Mutant),abs(Median_WT),abs(Median_Mutant),0,abs(Score_Mutant)]

    return ranked

def gene_translate(gene,GFF3):
    for key,value in GFF3.items():
        if gene in value[2]:
            return key

def printer(name,ranked,genes_WT,genes_Mutant,WT_fwd,WT_rev,Mutant_fwd,Mutant_rev,GFF3,CDS_fwd,CDS_rev,CDS_scaling_wt,CDS_scaling_mut,genome,upstream,downstream,WT_lengths,Mutant_lengths):
    with open(name,'w') as outp:
        outp.write('coord,strand,gene,offset,AKA,PlusOne,sense,WT CDS TPM,Mutant CDS TPM,Log2FC-CDS TPM,start,stop,dist start,dist stop,WT Count,Mutant Count,WT Median,Mutant Median,WT Score,Mutant Score,log2FC-Pause,Diff-short,short-WT,short-Mutant,Diff-16,16-WT,16-Mutant,Diff-17,17-WT,17-Mutant,Diff-18,18-WT,18-Mutant,Diff-long,long-WT,long-Mutant,sequence,threshold\n')
        for key,value in ranked.items():
            coord = int(key.split('_')[0])
            strand = str(key.split('_')[1])

            if int(coord) in genes_WT.keys():
                gene = str(genes_WT[int(coord)][0])
                sense = str(genes_WT[int(coord)][1])
                offset = str(genes_WT[int(coord)][2])
                AKA = str(genes_WT[int(coord)][3])
                plus1 = str(genes_WT[int(coord)][4])
           
            else:
                gene = str(genes_Mutant[int(coord)][0])
                sense = str(genes_Mutant[int(coord)][1])
                offset = str(genes_Mutant[int(coord)][2])
                AKA = str(genes_Mutant[int(coord)][3])
                plus1 = str(genes_Mutant[int(coord)][4])

            start,stop = pause_place_GFF(gene,strand,GFF3)

            if strand == '+':
                dstart = coord-start
                dstop = coord-stop
            else:
                dstart = start-coord
                dstop = stop-coord

            WT_counts = value[0]
            Mutant_counts = value[1]
            WT_Median = value[2]
            Mutant_Median = value[3]

            WT_Score = value[4]
            if 0 < WT_Score < 1:
                WT_Score = round(WT_Score,0)

            Mutant_Score = value[5]
            if 0 < Mutant_Score < 1:
                Mutant_Score = round(Mutant_Score,0)
            
            if strand == '+':
                WT_CDS_TPM = round(TPM_calc_CDS(start,stop,WT_fwd,CDS_scaling_wt),0)
                Mutant_CDS_TPM = round(TPM_calc_CDS(start,stop,Mutant_fwd,CDS_scaling_mut),0)
            else:
                WT_CDS_TPM = round(TPM_calc_CDS(stop,start,WT_rev,CDS_scaling_wt),0)
                Mutant_CDS_TPM = round(TPM_calc_CDS(stop,start,Mutant_rev,CDS_scaling_mut),0)
        
            if WT_CDS_TPM > 0 and Mutant_CDS_TPM > 0:
                Log2FC_CDS = round(np.log2(Mutant_CDS_TPM/WT_CDS_TPM),2)
            else:
                Log2FC_CDS = 'NA'
            
            if WT_Score > 0 and Mutant_Score > 0:
                Log2FC = round(np.log2(Mutant_Score/WT_Score),2)
            else:
                Log2FC = 'NA'

            if WT_lengths[coord] != 'NA' and Mutant_lengths[coord] != 'NA':
                Diff_short = Mutant_lengths[coord][0]-WT_lengths[coord][0]
                short_WT = WT_lengths[coord][0]
                short_Mutant = Mutant_lengths[coord][0]
                Diff_sixteen = Mutant_lengths[coord][1]-WT_lengths[coord][1]
                sixteen_WT = WT_lengths[coord][1]
                sixteen_Mutant = Mutant_lengths[coord][1]
                Diff_seventeen = Mutant_lengths[coord][2]-WT_lengths[coord][2]
                seventeen_WT = WT_lengths[coord][2]
                seventeen_Mutant = Mutant_lengths[coord][2]
                Diff_eighteen = Mutant_lengths[coord][3]-WT_lengths[coord][3]
                eighteen_WT = WT_lengths[coord][3]
                eighteen_Mutant = Mutant_lengths[coord][3]
                Diff_long = Mutant_lengths[coord][4]-WT_lengths[coord][4]
                long_WT = WT_lengths[coord][4]
                long_Mutant = Mutant_lengths[coord][4]
            
            else:
                Diff_short = 'NA'
                short_WT = 'NA'
                short_Mutant = 'NA'
                Diff_sixteen = 'NA'
                sixteen_WT = 'NA'
                sixteen_Mutant = 'NA'
                Diff_seventeen = 'NA'
                seventeen_WT = 'NA'
                seventeen_Mutant = 'NA'
                Diff_eighteen = 'NA'
                eighteen_WT = 'NA'
                eighteen_Mutant = 'NA'
                Diff_long = 'NA'
                long_WT = 'NA'
                long_Mutant = 'NA'

            if Log2FC != 'NA':
                if abs(Log2FC) >= 3:
                    differential = 'TRUE'
                else:
                    differential = 'FALSE'

            if strand == '+':
                seq = genome[coord-1].upper()
                seq = genome[coord-1-upstream:coord-1].lower()+seq
                seq = seq+genome[coord:coord+downstream].lower()
            else:
                seq = genome[coord-1].upper()
                seq = genome[coord-1-downstream:coord-1].lower()+seq
                seq = seq+genome[coord:coord+upstream].lower()
                seq = reverse_complement(seq)

            if WT_CDS_TPM != 0 and Mutant_CDS_TPM != 0:
                outp.write(str(coord)+','+strand+','+gene+','+offset+','+AKA+','+plus1+','+sense+','+str(WT_CDS_TPM)+','+str(Mutant_CDS_TPM)+','+str(Log2FC_CDS)+','+\
                str(start)+','+str(stop)+','+str(dstart)+','+str(dstop)+','+\
                str(WT_counts)+','+str(Mutant_counts)+','+str(WT_Median)+','+str(Mutant_Median)+','+str(WT_Score)+','+str(Mutant_Score)+','+str(Log2FC)+','+\
                str(Diff_short)+','+str(short_WT)+','+str(short_Mutant)+','+str(Diff_sixteen)+','+str(sixteen_WT)+','+str(sixteen_Mutant)+','+\
                str(Diff_seventeen)+','+str(seventeen_WT)+','+str(seventeen_Mutant)+','+str(Diff_eighteen)+','+str(eighteen_WT)+','+str(eighteen_Mutant)+','+\
                str(Diff_long)+','+str(long_WT)+','+str(long_Mutant)+','+str(seq)+','+differential+'\n')


@dxpy.entry_point('main')
def main(GFF3, genome, WT_Pauses, Mutant_Pauses, WT_Raw, Mutant_Raw, WT_Sizes, Mutant_Sizes, WT_Coverage_Fwd, WT_Coverage_Rev, Mutant_Coverage_Fwd, Mutant_Coverage_Rev, Output_Name_Prefix, Upstream, Downstream):

    # The following line(s) initialize your data object inputs on the platform
    # into dxpy.DXDataObject instances that you can start using immediately.

    GFF3 = dxpy.DXFile(GFF3)
    genome = dxpy.DXFile(genome)
    WT_Pauses = dxpy.DXFile(WT_Pauses)
    Mutant_Pauses = dxpy.DXFile(Mutant_Pauses)
    WT_Raw = dxpy.DXFile(WT_Raw)
    Mutant_Raw = dxpy.DXFile(Mutant_Raw)
    WT_Sizes = dxpy.DXFile(WT_Sizes)
    Mutant_Sizes = dxpy.DXFile(Mutant_Sizes)
    WT_Coverage_Fwd = dxpy.DXFile(WT_Coverage_Fwd)
    WT_Coverage_Rev = dxpy.DXFile(WT_Coverage_Rev)
    Mutant_Coverage_Fwd = dxpy.DXFile(Mutant_Coverage_Fwd)
    Mutant_Coverage_Rev = dxpy.DXFile(Mutant_Coverage_Rev)

    # The following line(s) download your file inputs to the local file system
    # using variable names for the filenames.

    dxpy.download_dxfile(GFF3.get_id(), "GFF3")

    dxpy.download_dxfile(genome.get_id(), "genome")

    dxpy.download_dxfile(WT_Pauses.get_id(), "WT_Pauses")

    dxpy.download_dxfile(Mutant_Pauses.get_id(), "Mutant_Pauses")

    dxpy.download_dxfile(WT_Raw.get_id(), "WT_Raw")

    dxpy.download_dxfile(Mutant_Raw.get_id(), "Mutant_Raw")

    dxpy.download_dxfile(WT_Sizes.get_id(), "WT_Sizes")

    dxpy.download_dxfile(Mutant_Sizes.get_id(), "Mutant_Sizes")

    dxpy.download_dxfile(WT_Coverage_Fwd.get_id(), "WT_Coverage_Fwd")

    dxpy.download_dxfile(WT_Coverage_Rev.get_id(), "WT_Coverage_Rev")

    dxpy.download_dxfile(Mutant_Coverage_Fwd.get_id(), "Mutant_Coverage_Fwd")

    dxpy.download_dxfile(Mutant_Coverage_Rev.get_id(), "Mutant_Coverage_Rev")

    # Fill in your application code here.

   #build genome dict
    sequence = genome_yield("genome")

    #build length dict
    WT_lengths = length_distribution("WT_Sizes")
    Mutant_lengths = length_distribution("Mutant_Sizes")

    #build pause dict
    pauses_WT,genes_WT = read_pause("WT_Pauses")
    pauses_Mutant,genes_Mutant = read_pause("Mutant_Pauses")

    #load up gff file and build TU and CDS dicts
    GFF3,CDS_fwd,CDS_rev = GFF_build('GFF3')

    #clean up pause dicts
    genes_WT_list = [x[0] for x in genes_WT.values()]
    genes_Mutant_list = [x[0] for x in genes_Mutant.values()]

    remove_genes = []
    for gene in genes_WT_list:
        try:
            GFF3[gene]
        except KeyError:
            remove_genes.append(gene)
    for gene in  genes_Mutant_list:
        try:
            GFF3[gene]
        except KeyError:
            remove_genes.append(gene)

    remove_pos = []
    for key,value in genes_WT.items():
        if value[0] in remove_genes:
            remove_pos.append(key)
    for key,value in genes_Mutant.items():
        if value[0] in remove_genes:
            remove_pos.append(key)

    for item in remove_pos:
        if item in pauses_WT.keys():
            del pauses_WT[item]
        if  item in pauses_Mutant.keys():
            del pauses_Mutant[item]

    #load up wig files
    WT_wig,Mutant_wig = read_wig("WT_Raw"),read_wig("Mutant_Raw")

    #rank all pauses
    ranked = pause_rank(pauses_WT,pauses_Mutant,WT_wig,Mutant_wig)

    #clear large wigs
    WT_wig,Mutant_wig = {},{}

    #build coverage lists
    WT_fwd = read_coverage('WT_Coverage_Fwd')
    WT_rev = read_coverage('WT_Coverage_Rev')
    Mutant_fwd = read_coverage('Mutant_Coverage_Fwd')
    Mutant_rev = read_coverage('Mutant_Coverage_Rev')

    #calculate all TPMs of TUs and CDSs
    CDS_wt,CDS_mut = TPM_scaling(CDS_fwd,CDS_rev,WT_fwd,WT_rev),TPM_scaling(CDS_fwd,CDS_rev,Mutant_fwd,Mutant_rev)

    # The following line(s) use the Python bindings to upload your file outputs
    # after you have created them on the local file system.  It assumes that you
    # have used the output field name for the filename for each output, but you
    # can change that behavior to suit your needs.

    output_file_nom = Output_Name_Prefix+".csv"
    printer(output_file_nom,ranked,genes_WT,genes_Mutant,WT_fwd,WT_rev,Mutant_fwd,Mutant_rev,GFF3,CDS_fwd,CDS_rev,CDS_wt,CDS_mut,sequence,Upstream,Downstream,WT_lengths,Mutant_lengths)
    Differential_Pauses = dxpy.upload_local_file(output_file_nom)
    output = {}
    output["Differential_Pauses"] = dxpy.dxlink(Differential_Pauses)

    return output

dxpy.run()
