#!/usr/bin/env python
# differential_pauses_bb 0.0.1
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# See https://documentation.dnanexus.com/developer for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os
import dxpy
import numpy as np

def genome_yield(fasta_name):
    seq = ''
    with open(fasta_name) as inp:
        for line in inp:
            if line[0] != '>':
                seq = seq+str(line.strip())
    return seq

def reverse_complement(seq):
    complement = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A','a': 't', 'c': 'g', 'g': 'c', 't': 'a'}
    bases = list(seq)
    bases = reversed([complement.get(base,base) for base in bases])
    bases = ''.join(bases)
    return bases

def median(lst):
    n = len(lst)
    s = sorted(lst)
    return (sum(s[n//2-1:n//2+1])/2.0, s[n//2])[n % 2] if n else None

def read_wig(wig_fyle):
    #create list of coverage values, position dependent
    return_dict = {}
    with open(wig_fyle,"r") as inp:
        for line in inp:
            return_dict[int(line.strip().split('\t')[0])] = [int(line.strip().split('\t')[1]),float(line.strip().split('\t')[3])]
    return return_dict

def read_pause(fyle):
    return_dict = {}
    gene_dict ={}
    with open(fyle,'r') as inp:
        firstline = inp.readline()
        for line in inp:
            if int(line.strip().split('\t')[8]) > 0:
                peak = int(line.strip().split('\t')[1])
                strand = '+'
                gene = line.strip().split('\t')[0]
                dist = line.strip().split('\t')[2]
                sense = line.strip().split('\t')[6]
            else:
                peak = int(line.strip().split('\t')[1])
                strand = '-'
                gene = line.strip().split('\t')[0]
                dist = line.strip().split('\t')[2]
                sense = line.strip().split('\t')[6]
            return_dict[peak] = [strand]
            gene_dict[peak] = [gene,sense]

    return return_dict,gene_dict

def pause_rank(pauses_WT,pauses_Mutant,wig_WT,wig_Mutant):
    ranked = {}
    for key,value in pauses_WT.items():
        strand = value[0]
        count_WT = wig_WT[key][0]
        count_Mutant = wig_Mutant[key][0]
        Median_WT = wig_WT[key][1]
        Median_Mutant = wig_Mutant[key][1]
        if Median_WT == 0:
            if strand == '+':
                Median_WT = 1
            else:
                Median_WT = -1
        if abs(Median_Mutant) > 1 and abs(count_Mutant) !=0:
            if np.sign(count_WT) == np.sign(count_Mutant) and np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_WT = round(abs(count_WT)/abs(Median_WT),2)
                Score_Mutant = round(abs(count_Mutant)/abs(Median_Mutant),2)
                ranked[str(key)+'_'+str(strand)] = [abs(count_WT),abs(count_Mutant),abs(Median_WT),abs(Median_Mutant),abs(Score_WT),abs(Score_Mutant)]
        elif abs(Median_Mutant) > 1 and abs(count_Mutant) == 0:
            if np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_WT = round(abs(count_WT)/abs(Median_WT),2)
                ranked[str(key)+'_'+str(strand)] = [abs(count_WT),0,abs(Median_WT),abs(Median_Mutant),abs(Score_WT),0]

    for key,value in pauses_Mutant.items():
        strand = value[0]
        count_WT = abs(wig_WT[key][0])
        count_Mutant = abs(wig_Mutant[key][0])
        Median_WT = abs(wig_WT[key][1])
        Median_Mutant = abs(wig_Mutant[key][1])
        if Median_Mutant == 0:
            if strand == '+':
                Median_Mutant = 1
            else:
                Median_Mutant = -1
        if abs(Median_WT) > 1 and abs(count_WT) !=0:
            if np.sign(count_WT) == np.sign(count_Mutant) and np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_WT = round(abs(count_WT)/abs(Median_WT),1)
                Score_Mutant = round(abs(count_Mutant)/abs(Median_Mutant),2)
                ranked[str(key)+'_'+str(strand)] = [abs(count_WT),abs(count_Mutant),abs(Median_WT),abs(Median_Mutant),abs(Score_WT),abs(Score_Mutant)]
        elif abs(Median_WT) > 1 and abs(count_WT) == 0:
            if np.sign(Median_WT) == np.sign(Median_Mutant):
                Score_Mutant = round(abs(count_Mutant)/abs(Median_Mutant),2)
                ranked[str(key)+'_'+str(strand)] = [0,abs(count_Mutant),abs(Median_WT),abs(Median_Mutant),0,abs(Score_Mutant)]

    return ranked

def printer(name,dyct,genes_WT,genes_Mutant,genome,upstream,downstream):
    with open(name,'w') as outp:
        outp.write('coord,strand,gene,sense,WT Count,Mutant Count,WT Median,Mutant Median,WT Score,Mutant Score,log2FC,log2Diff,sequence,threshold\n')
        for key,value in dyct.items():
            coord = int(key.split('_')[0])
            strand = str(key.split('_')[1])

            WT_counts = value[0]
            Mutant_counts = value[1]
            WT_Median = value[2]
            Mutant_Median = value[3]

            WT_Score = value[4]
            if 0 < WT_Score < 1:
                WT_Score = round(WT_Score,0)

            Mutant_Score = value[5]
            if 0 < Mutant_Score < 1:
                Mutant_Score = round(Mutant_Score,0)

            if WT_Score > 0 and Mutant_Score > 0:
                Log2FC = round(np.log2(Mutant_Score/WT_Score),2)
            else:
                Log2FC = 'NA'

            if abs(WT_Score-Mutant_Score) != 0:
                Log2Diff = round(np.log2(abs(WT_Score-Mutant_Score)),2)
            else:
                Log2Diff = 0

            if Log2FC != 'NA':
                if abs(Log2FC) >= 3:
                    differential = 'TRUE'
                else:
                    differential = 'FALSE'

            if int(coord) in genes_WT.keys():
                gene = str(genes_WT[int(coord)][0])
                sense = str(genes_WT[int(coord)][1])
            else:
                gene = str(genes_Mutant[int(coord)][0])
                sense = str(genes_Mutant[int(coord)][1])

            if strand == '+':
                seq = genome[coord-1].upper()
                seq = genome[coord-1-upstream:coord-1].lower()+seq
                seq = seq+genome[coord:coord+downstream].lower()
            else:
                seq = genome[coord-1].upper()
                seq = genome[coord-1-downstream:coord-1].lower()+seq
                seq = seq+genome[coord:coord+upstream].lower()
                seq = reverse_complement(seq)


            outp.write(str(coord)+','+strand+','+gene+','+sense+\
            ','+str(WT_counts)+','+str(Mutant_counts)+','+str(WT_Median)+','+str(Mutant_Median)+','+str(WT_Score)+','+str(Mutant_Score)+\
            ','+str(Log2FC)+','+str(Log2Diff)+','+str(seq)+','+differential+'\n')


@dxpy.entry_point('main')
def main(genome, WT_pauses, WT_raw, Mutant_Pauses, Mutant_raw, upstream, downstream):

    # The following line(s) initialize your data object inputs on the platform
    # into dxpy.DXDataObject instances that you can start using immediately.

    genome = dxpy.DXFile(genome)
    WT_pauses = dxpy.DXFile(WT_pauses)
    WT_raw = dxpy.DXFile(WT_raw)
    Mutant_Pauses = dxpy.DXFile(Mutant_Pauses)
    Mutant_raw = dxpy.DXFile(Mutant_raw)

    # The following line(s) download your file inputs to the local file system
    # using variable names for the filenames.

    dxpy.download_dxfile(genome.get_id(), "genome")

    dxpy.download_dxfile(WT_pauses.get_id(), "WT_pauses")

    dxpy.download_dxfile(WT_raw.get_id(), "WT_raw")

    dxpy.download_dxfile(Mutant_Pauses.get_id(), "Mutant_Pauses")

    dxpy.download_dxfile(Mutant_raw.get_id(), "Mutant_raw")

    # Fill in your application code here.

    #build genome dict
    sequence = genome_yield("genome")

    #build pause dict
    pauses_WT,genes_WT = read_pause("WT_pauses")
    pauses_Mutant,genes_Mutant = read_pause("Mutant_Pauses")

    #load up wig files
    WT_wig,Mutant_wig = read_wig("WT_raw"),read_wig("Mutant_raw")

    #rank all pauses
    ranked = pause_rank(pauses_WT,pauses_Mutant,WT_wig,Mutant_wig)

    #clear large wigs
    WT_wig,Mutant_wig = {},{}

    printer("Differential_Pauses.csv",ranked,genes_WT,genes_Mutant,sequence,upstream,downstream)

    # The following line(s) use the Python bindings to upload your file outputs
    # after you have created them on the local file system.  It assumes that you
    # have used the output field name for the filename for each output, but you
    # can change that behavior to suit your needs.

    Differential_Pauses = dxpy.upload_local_file("Differential_Pauses.csv")

    # The following line fills in some basic dummy output and assumes
    # that you have created variables to represent your output with
    # the same name as your output fields.

    output = {}
    output["Differential_Pauses"] = dxpy.dxlink(Differential_Pauses)

    return output

dxpy.run()
